# Доклад «What? if()?»

## Tbilisi JS, 28 декабря 2025

Всем привет\! И всех с наступающим \=) Я очень рада выступать сегодня перед вами, большое спасибо организаторам Tbilisi JS за приглашение. Отличный способ завершить год в прекрасной компании.

Мой доклад называется «What? if()?» потому что те, кому я рассказывала тему своего выступления и кто не очень погружен в мир CSS буквально восклицали «Что? В CSS есть if?». Отсюда и родилось название.
Собственно я расскажу вам сегодня о довольно свежей новинке — функции if(). Но сперва немного о себе.

Меня зовут Алёна Батицкая. Последние 10 лет я занимаюсь фронтендом. Кроме того я Google developer Expert по web, редактор в Доке. Пишу и перевожу статьи, преподаю и выступаю. Кстати, поставьте плюсики в чат, кто знает про Доку и минус, если не знаете? Это мой маленький фетишь — смотреть сколько людей уже про нас знает \=)
На слайде указаны мои контакты, если вдруг вы захотите пообщаться после доклада или у вас остануться вопросы — пишите.

Окей, давайте перейдём к теме. И свой рассказ я начну со слайда, который обычно находится в конце. Я сделаю это чтобы вы, слушая мой рассказ, сразу понимали, можно ли уже тащить это в прод (если вы очень смелый) или в свои пет-проекты.
Какая на сегодняшний день поддержка у функции if()?

Baseline iframe / screenshot

Поскольку фича совсем новая, появилась только в Chrome 137 версии и выше, то поддержка пока что не очень. Но оно и понятно. Будем надеятся, что в скором времени это изменится.

Супер, самая главная интрига раскрыта. Дальше можем общаться расслаблено.

Так что же такое эта самая функция if()? Это способ задать значение свойству в зависимости от условий. Выглядит это, например, так:

.block {
flex-direction: if(
    media(width \< 700px): column;
    else: row;
  )
}

**ДЕМО**

Общий синтаксис функции: внутри CSS-правила для свойства, которое хотим менять по условию, мы пишем значение с использованием функции **if()**. Внутри круглых скобок перечисляем все условия, разделяя их точкой с запятой. В конце, если хотим, можем задать дефолтную ветку **else**. Значение из неё сработает когда ни одно из условий выше не было истиной.

Необходимый минимум для работы if, чтобы браузер воспринял его как валидное значение, выглядит так:
background-image: if();
Ну, окей, это бессмысленно, будет просто пустое значение. Пример чуть ближе к жизни:
background-color: if(else: yellow);
Хотя и он тоже не особо имеет смысл, но это совершенно валидная запись.

Кстати, просто к сведению, мы можем вкладывать if в if \=)

Какие условия мы можем задавать внутри if?
В данный момент поддерживается три типа условий:

**style** — внутри ветки с условием style мы можем устанавливать значение свойства в зависимости от значения кастомной переменной.
Предположим, у нас есть переменная, отвечающая за тему на вашем сайте. У неё возможны значения **light, dark** и, например, **pink.** Пусть light будет по умолчанию, запишем значение для этой темы в else ветку. Для dark будем условие style(--theme: dark): white;
Для темы pink будет условие style(--theme: pink): gray;
Пока внутри условий styles можно проверять только кастомные переменные и только на строгое равенство. Нельзя написать style(--angle \< 45), так не сработает. Хотя это было бы полезно\!
Этот тип проверки чем-то похож на директиву @container, если вы с ней уже знакомы.

**media** — тут всё как с обычными директивами @media, с которыми каждый из вас уже работал. Только для одного свойства. Можем использовать как старый синтаксис, так и новый.
media(min-width: 700px): white;
media(width \>= 700px): white;
Эти ветки равнозначны.
Кроме размеров экрана не стоит забывать, что media позволяет нам проверять, например, тип устройства→ media(print) задаст стили для печати.
Или тип устройства ввода → media(hover: hover) задаст стили для устройств с мышкой.
А media(prefers-reduced-motion: reduce) проверит, не отключил ли пользователь лишние движения.
Освежить знания про все возможные проверки media можно в Доке → https://doka.guide/css/media/

**supports** — работает аналогично директиве @support, проверяет поддерживает ли браузер пользователя какую-то CSS-фичу. Например, можем проверять поддерживается ли новое значение для создания плиточной раскладки grid-lanes. И применять просто grid, если нет.
color: if(
supports(display: grid-lanes): grid-lanes;
else: grid;
)

Можно ли комбинировать условия? Коротко, да, но не совсем \=)
Можно использовать логический and, or и not внутри одного типа условия.
Например,
style((--theme: dark) and (--user: admin)): red — так можно.
А вот
media(width \< 700\) and style(--user: admin): red — уже нельзя, будет невалидно.

Кстати, мы можем использовать if() не только как значение целиком, но и как часть значения.
К примеру, зададим разный цвет бордера для разных условий

border: 3px solid if(media(width \> 700px): red; else: green;)

При написании условий, особенно медиа-условий на размеры экрана очень важен порядок. Сработает первое правило, вернувшее true. А не последнее, как в привычном каскаде.
Вот так квадрат окрасится только в синий и остальные правила будут проигнорированы.
**Демо**

А вот так сработают все правила по очереди
**Демо**

Кстати, а что там с каскадом? Что будет в результате выполнения такого кода?
**Демо с if и ниже блок с переопределением**

Всё просто: каскад это база. Мы же всё ещё говорим про каскадные стили \=)
Поэтому сработает это так: нижестоящее правило перебьет if. Потому что if в итоге вычисляется в конечное значение и никакого веса не добавляет сам по себе. Как и все другие функции, на самом-то деле.
Это нам на руку в момент, когда мы хотим задать фоллбэк. Всё стандартно: сперва обычное правило без функции, ниже — с функцией.

Можно комбинировать if с любыми другими функциями. Например, внутри calc() можно задать условия:

width: calc(if(
style(--mode: compact): 50%;
else: 80%;) \- 2em)

Тут главное не запутаться в скобках и не потерять точки с запятой \=)

Вы можете сказать «Но у нас уже всё это было. И в более удобном формате CSS-правил, где можно переопределить сразу несколько свойств». И я с вами соглашусь. Действительно, в случаях, когда нам нужно поменять сразу много стилей имеет смысл использовать директивы.

Но, во-первых, бывает так, что директива, тот же media, отдалён от оригинального блока правил или даже находится в другом файле. Нам нужно знать или искать, где стили переопределяются.

Во-вторых, нам нужно помнить про каскад. В больших проектах стили могут быть разбросаны по большому количеству файлов и нужно следить за порядком их подключения, чтобы понимать, что сработает в конечном итоге.

В-третьих, реально бывают ситуации, когда вам надо переопределить одно свойство. В этом случае гораздо удобнее написать всю логику внутри одного блока. Она вся будет перед глазами.

Но, на самом деле, я считаю, что новая функция очень хорошо впишется в юзкейс создания тем и ui-kitов. Все мы знаем эти простыни переменных для светлой и тёмной темы. Гораздо удобнее было бы всё определить один раз, но с условиями.
**ПРИМЕР**

Ещё один закономерный вопрос, который мог у вас возникнуть: зачем нам, по сути, синтаксический сахар для директив? Чем не устраивал старый подход?
На этот вопрос у меня будет чуть более философский ответ. Мне кажется, что вектор развития CSS, который я наблюдаю последние 10 лет, стремится от фиксированных значений в сторону вычисляемых значений. У нас разросся парк устройств, размеров экранов, условий, в которых пользователь взаимодействует с вебом.

Как мне кажется, это всё началось с flexbox, и потом продолжилось в гридах, директивах и контейнер кверис. Это если говорить на высоком уровне раскладок и блоков стилей.
Но кроме того у нас появилась просто уйма новых функций, позволяющих оперировать вычисляемыми значениями. От всеми любимой calc(), до color(). От clamp() до minmax(). И это далеко не всё\! Новые ключевые слова. От currentColor до fit-content. Думаю, вы поняли о чём я говорю.

И это уводит CSS в сторону деклоративности, позволяет продумывать и записывать более сложную логику. Безусловно, это не деклоративность в чистом виде, но уже на шаг дальше от императивности.
Вы можете возразить, что у нас уже есть JS, который умеет всё это делать, зачем нам логика в CSS? Помимо того, что браузер великолепно оптимизирует работу со стилями и вычисление конечных значений, я считаю, что «мухи отдельно, котлеты отдельно». Мне очень нравится разделять технологии по назначению. HTML отвечает за семантику и контент. CSS отвечает за стили. А JS нужен для логики. Понимаю, что это слегка наивный взгляд, но мне нравится наблюдать, как рабочая группа CSS отслеживает наиболее частые юзкейсы, где разработчики используют JS для стилей и перетаскивает эту логику в новые фичи. Мне кажется, это очень хороший, здоровый путь развития.

На этом у меня, пожалуй, всё. На слайде представлены материалы, которые я использовала для подготовки доклада.

Спасибо за внимание и с наступающим\!
